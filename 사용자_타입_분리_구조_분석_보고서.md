# 사용자 타입 분리 구조 분석 보고서

## 📋 현재 구조 이해

### 1. 두 가지 사용자 타입

#### A. 결제 고객 (크루즈가이드 지니)
- **비밀번호**: `3800`
- **로그인 페이지**: `/login`
- **채팅 페이지**: `/chat`
- **고객 상태**: `customerStatus: 'active'`
- **고객 출처**: `customerSource: 'cruise-guide'`
- **특징**: 
  - 기존 고객 정보로 로그인
  - 구매한 상품으로 온보딩
  - 실제 크루즈 여행 정보 사용

#### B. 잠재고객 (크루즈가이드 지니 3일 체험)
- **비밀번호**: `1101`
- **로그인 페이지**: `/login-test`
- **채팅 페이지**: `/chat-test`
- **고객 상태**: `customerStatus: 'test'`
- **고객 출처**: `customerSource: 'test-guide'`
- **특징**:
  - 이름/연락처 아무렇게나 입력 가능
  - 1101 비밀번호만 맞으면 로그인
  - 샘플 여행 정보 사용 (SAMPLE-MED-001)

---

## 🔍 현재 코드 구조 분석

### 1. 라우팅 분리

#### `/chat` 페이지 (`app/chat/page.tsx`)
```typescript
export default async function ChatPage() {
  // 테스트 모드 사용자는 /chat-test로 리다이렉트
  const testModeInfo = await checkTestMode();
  const correctPath = getCorrectPath('/chat', testModeInfo);
  
  if (correctPath !== '/chat') {
    redirect(correctPath);
  }
  
  // 결제 고객용 채팅 UI
  return (
    <div>
      <TopBar />
      <ChatInteractiveUI />
    </div>
  );
}
```

#### `/chat-test` 페이지 (`app/chat-test/page.tsx`)
```typescript
export default async function ChatTestPage() {
  // 테스트 모드 체크
  const testModeInfo = await checkTestMode();
  
  // 테스트 모드가 아니면 일반 채팅으로 리다이렉트
  if (!testModeInfo.isTestMode) {
    redirect('/chat');
  }
  
  // 테스트 모드면 튜토리얼 버전 렌더링
  return <TutorialChatPage testModeInfo={testModeInfo} />;
}
```

### 2. 컴포넌트 공유 문제

**현재 상황**:
- `/chat` → `ChatInteractiveUI` 직접 사용
- `/chat-test` → `TutorialChatPage` → `ChatInteractiveUI` 사용

**문제점**:
- 두 사용자 타입이 같은 `ChatInteractiveUI` 컴포넌트를 공유
- `ChatInteractiveUI` 내부에서 사용자 타입을 구분하는 로직이 명확하지 않음
- 두 사용자 타입이 완전히 분리되어야 한다는 요구사항과 맞지 않음

### 3. 테스트 모드 체크 로직

#### `lib/test-mode.ts`
```typescript
export async function checkTestMode(): Promise<TestModeInfo> {
  // 세션에서 사용자 정보 조회
  const user = session.User;
  const isTestMode = user.customerStatus === 'test';
  
  // customerStatus가 'test'이면 테스트 모드
  return {
    isTestMode: true/false,
    testModeStartedAt: ...,
    remainingHours: ...,
  };
}
```

**구분 기준**:
- `customerStatus === 'test'` → 테스트 모드
- `customerStatus === 'active'` → 결제 고객

---

## ⚠️ 발견된 문제점

### 1. 컴포넌트 공유로 인한 혼란
- `ChatInteractiveUI`가 두 사용자 타입에서 공유됨
- 사용자 타입별로 다른 UI/UX가 필요한데 같은 컴포넌트 사용
- 테스트 모드 체크가 `ChatInteractiveUI` 내부에서 명확하지 않음

### 2. 데이터 분리 부족
- 결제 고객: 실제 구매한 상품의 여행 정보
- 테스트 고객: 샘플 여행 정보 (SAMPLE-MED-001)
- 하지만 같은 컴포넌트에서 처리

### 3. 온보딩 프로세스 차이
- 결제 고객: 구매한 상품으로 온보딩
- 테스트 고객: 샘플 상품으로 자동 온보딩
- 하지만 같은 컴포넌트에서 처리

---

## 💡 권장 해결 방안

### 옵션 1: 완전 분리 (권장)
- `ChatInteractiveUI`를 두 개로 분리:
  - `ChatInteractiveUI` (결제 고객용)
  - `TestChatInteractiveUI` (테스트 고객용)
- 각각 독립적인 컴포넌트로 관리

### 옵션 2: Props로 구분
- `ChatInteractiveUI`에 `isTestMode` prop 추가
- 내부에서 사용자 타입에 따라 다른 UI 렌더링
- 하지만 완전 분리보다는 덜 명확함

### 옵션 3: 현재 구조 유지 + 명확한 구분
- 현재 구조 유지하되
- `ChatInteractiveUI` 내부에서 사용자 타입을 명확히 구분
- 각 사용자 타입별로 다른 데이터/로직 사용

---

## 🎯 다음 단계

1. **사용자 의도 확인**: 완전 분리 vs Props 구분
2. **컴포넌트 구조 재설계**: 필요시 분리
3. **데이터 흐름 명확화**: 각 사용자 타입별 데이터 소스 분리
4. **테스트**: 두 사용자 타입이 서로 영향을 주지 않는지 확인


