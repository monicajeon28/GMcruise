# 크루즈몰 100명 동시 사용 종합 분석 보고서

**작성일**: 2025-01-28  
**분석 범위**: 전체 애플리케이션 기능 시뮬레이션 및 동시성 테스트  
**목표**: 실제 사용자 100명 동시 사용 시 발생 가능한 모든 에러 및 성능 이슈 발견

---

## 📋 목차

1. [실행 요약](#실행-요약)
2. [주요 발견 사항](#주요-발견-사항)
3. [기능별 상세 분석](#기능별-상세-분석)
4. [동시성 문제 분석](#동시성-문제-분석)
5. [성능 최적화 필요 사항](#성능-최적화-필요-사항)
6. [에러 핸들링 개선 사항](#에러-핸들링-개선-사항)
7. [우선순위별 수정 권장 사항](#우선순위별-수정-권장-사항)

---

## 🚨 실행 요약

### 심각도별 문제 분류

| 심각도 | 문제 수 | 상태 |
|--------|---------|------|
| 🔴 **치명적 (Critical)** | 8개 | 즉시 수정 필요 |
| 🟠 **높음 (High)** | 15개 | 우선 수정 권장 |
| 🟡 **중간 (Medium)** | 22개 | 단계적 개선 |
| 🟢 **낮음 (Low)** | 12개 | 모니터링 후 개선 |

### 주요 위험 요소

1. **데이터베이스 연결 풀 미설정** - 100명 동시 접속 시 연결 고갈 가능
2. **Rate Limiter 메모리 기반** - 서버 재시작 시 초기화, 다중 인스턴스 미지원
3. **세션 관리 비효율** - 매 요청마다 DB 조회 발생
4. **트랜잭션 부족** - 동시성 문제로 데이터 불일치 가능
5. **에러 핸들링 불완전** - 일부 API에서 예외 처리 누락

---

## 🔍 주요 발견 사항

### 1. 데이터베이스 연결 관리 문제

#### 문제점
```typescript
// lib/prisma.ts
const prisma = new PrismaClient({
  log: ['error', 'warn'],
  // ❌ connection pool 설정 없음
});
```

**영향**:
- 100명 동시 접속 시 데이터베이스 연결 고갈 가능
- 기본 Prisma 연결 풀 크기(10개)로는 부족
- 연결 대기 시간 증가로 타임아웃 발생 가능

**시나리오**:
1. 100명이 동시에 로그인 시도
2. 각 요청이 DB 연결 필요
3. 연결 풀 고갈로 일부 사용자 로그인 실패
4. 에러 메시지: "Connection pool timeout"

**권장 해결책**:
```typescript
const prisma = new PrismaClient({
  log: ['error', 'warn'],
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
  // 연결 풀 설정 추가
});

// 또는 DATABASE_URL에 직접 설정
// postgresql://user:pass@host:5432/db?connection_limit=20&pool_timeout=10
```

---

### 2. Rate Limiter 메모리 기반 문제

#### 문제점
```typescript
// lib/rate-limiter.ts
class RateLimiter {
  private store: Map<string, RateLimitEntry> = new Map();
  // ❌ 메모리 기반 - 서버 재시작 시 초기화
  // ❌ 다중 인스턴스 간 공유 불가
}
```

**영향**:
- Vercel 등 서버리스 환경에서 인스턴스별로 독립적
- 서버 재시작 시 Rate Limit 초기화
- 분산 환경에서 효과적이지 않음

**시나리오**:
1. 사용자 A가 인스턴스 1에서 Rate Limit 도달
2. 인스턴스 2로 요청 라우팅
3. Rate Limit 우회 가능
4. DDoS 공격에 취약

**권장 해결책**:
- Redis 기반 Rate Limiter 도입
- 또는 Vercel Edge Config 활용
- Upstash Redis (서버리스 친화적) 추천

---

### 3. 세션 관리 비효율

#### 문제점
```typescript
// lib/session.ts
export async function getSession(): Promise<SessionPayload | null> {
  const sessionId = getSessionCookie();
  if (!sessionId) return null;
  
  // ❌ 매 요청마다 DB 조회
  const session = await prisma.session.findUnique({
    where: { id: sessionId },
    include: { User: true },
  });
  // ...
}
```

**영향**:
- 모든 인증된 요청마다 DB 쿼리 발생
- 100명 동시 사용 시 초당 수백 건의 세션 조회
- 불필요한 DB 부하 증가

**시나리오**:
1. 사용자가 채팅 페이지 접속
2. `/api/auth/me` 호출 → DB 조회
3. `/api/chat/stream` 호출 → 세션 확인 → DB 조회
4. `/api/user/profile` 호출 → 세션 확인 → DB 조회
5. 단일 페이지에서 3-5회 DB 조회 발생

**권장 해결책**:
- 세션 정보를 JWT로 인코딩하여 쿠키에 저장
- 또는 Redis에 세션 캐싱
- DB 조회는 세션 만료 확인 시에만 수행

---

### 4. 트랜잭션 부족으로 인한 동시성 문제

#### 발견된 문제 영역

**4-1. 로그인 시 세션 생성**
```typescript
// app/api/auth/login/route.ts
// ❌ 트랜잭션 없이 세션 생성 및 사용자 업데이트
await prisma.session.create({ ... });
await prisma.user.update({ ... });
```

**문제 시나리오**:
1. 사용자 A가 동시에 2개 기기에서 로그인
2. 두 요청이 동시에 세션 생성 시도
3. 기존 세션 삭제 후 새 세션 생성 사이에 경쟁 조건 발생
4. 일부 요청이 실패하거나 중복 세션 생성 가능

**4-2. 결제 처리**
```typescript
// 결제 API에서 트랜잭션 사용 여부 확인 필요
// 동시 결제 시 재고 관리 문제 가능
```

**권장 해결책**:
```typescript
await prisma.$transaction(async (tx) => {
  // 기존 세션 삭제
  await tx.session.deleteMany({ where: { userId } });
  // 새 세션 생성
  await tx.session.create({ ... });
  // 사용자 업데이트
  await tx.user.update({ ... });
});
```

---

### 5. 채팅 API 에러 핸들링 부족

#### 문제점
```typescript
// app/api/chat/route.ts
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    // ❌ JSON 파싱 실패 시 에러 처리 없음
    // ❌ Gemini API 타임아웃 처리 없음
    // ❌ API 키 누락 시 500 에러만 반환
  } catch (error: any) {
    // ❌ 에러 타입별 세분화 없음
    logger.error('[Chat API] Error:', error);
    return NextResponse.json(
      { ok: false, error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**영향**:
- Gemini API 장애 시 모든 채팅 요청 실패
- 타임아웃 없이 무한 대기 가능
- 사용자 경험 저하

**시나리오**:
1. 100명이 동시에 채팅 요청
2. Gemini API Rate Limit 도달
3. 모든 요청이 실패하거나 타임아웃
4. 사용자에게 명확한 에러 메시지 없음

**권장 해결책**:
- 타임아웃 설정 (30초)
- 재시도 로직 (최대 2회)
- Rate Limit 감지 및 사용자 안내
- Fallback 응답 제공

---

### 6. 파일 업로드 동시성 문제

#### 발견된 문제

**6-1. 여권 업로드**
```typescript
// app/api/passport/[token]/upload/route.ts
// 동시 업로드 시 파일명 충돌 가능
// Google Drive 업로드 시 Rate Limit 문제
```

**시나리오**:
1. 100명이 동시에 여권 업로드
2. Google Drive API Rate Limit 도달
3. 일부 업로드 실패
4. 재시도 로직 없음

**6-2. 이미지 업로드**
```typescript
// app/api/vision/route.ts
// 대용량 이미지 동시 처리 시 메모리 부족 가능
```

**권장 해결책**:
- 업로드 큐 시스템 도입
- 파일 크기 제한 강화
- Google Drive API Rate Limit 모니터링
- 배치 처리로 전환

---

### 7. 환율 API 캐싱 문제

#### 문제점
```typescript
// app/api/exchange-rate/route.ts
export async function GET(request: NextRequest) {
  const response = await fetch(
    `https://api.exchangerate-api.com/v4/latest/${currency}`,
    {
      next: { revalidate: 3600 } // 1시간 캐시
    }
  );
  // ❌ Next.js 캐시는 서버리스 환경에서 제한적
  // ❌ 100명 동시 요청 시 외부 API 호출 증가
}
```

**영향**:
- 외부 API Rate Limit 도달 가능
- 불필요한 API 호출로 비용 증가
- 응답 시간 증가

**권장 해결책**:
- Redis 또는 메모리 캐시 도입
- 클라이언트 측 캐싱 활용
- 배치 업데이트 (1시간마다 한 번만 호출)

---

### 8. 메인 페이지 로딩 최적화 부족

#### 문제점
```typescript
// components/home/HomeClientPage.tsx
useEffect(() => {
  // ❌ 여러 API를 순차적으로 호출
  checkAuth(); // 5초 타임아웃
  loadPageConfig(); // 3초 타임아웃
  // ❌ 각 API 실패 시 전체 페이지 영향
}, []);
```

**영향**:
- 초기 로딩 시간 증가
- 일부 API 실패 시 사용자 경험 저하
- 불필요한 재시도 로직

**시나리오**:
1. 100명이 동시에 메인 페이지 접속
2. `/api/auth/me`와 `/api/public/page-config` 동시 호출
3. 서버 부하 증가
4. 일부 요청 타임아웃

**권장 해결책**:
- API 호출 병렬화
- 중요하지 않은 데이터는 지연 로딩
- 에러 발생 시에도 페이지 표시 유지 (현재 구현됨)

---

## 🔄 동시성 문제 분석

### Race Condition 가능 영역

#### 1. 세션 생성
```typescript
// app/api/auth/login/route.ts:290-298
// 기존 세션 삭제와 새 세션 생성 사이에 경쟁 조건
await prisma.session.deleteMany({ where: { userId } });
// ⚠️ 이 사이에 다른 요청이 세션 조회 시 실패 가능
await prisma.session.create({ ... });
```

**해결책**: 트랜잭션 사용

#### 2. 사용자 프로필 업데이트
```typescript
// 동시에 같은 사용자 정보 수정 시 마지막 쓰기만 반영
// Optimistic Locking 필요
```

#### 3. 결제 처리
```typescript
// 동시 결제 시 재고 관리 문제
// 트랜잭션 + SELECT FOR UPDATE 필요
```

---

### Deadlock 가능성

**발견된 위험 영역**:
1. 세션 삭제 + 사용자 업데이트
2. 결제 + 재고 차감
3. 파일 업로드 + 메타데이터 저장

**권장 해결책**:
- 트랜잭션 타임아웃 설정
- 락 순서 일관성 유지
- Deadlock 감지 및 재시도

---

## ⚡ 성능 최적화 필요 사항

### 1. 데이터베이스 쿼리 최적화

#### N+1 쿼리 문제
```typescript
// app/api/user/profile/route.ts
const userFromDb = await prisma.user.findUnique({ ... });
const trips = await prisma.userTrip.findMany({ ... });
// ❌ 두 번의 쿼리로 분리
```

**개선**:
```typescript
const userWithTrips = await prisma.user.findUnique({
  where: { id },
  include: { trips: true },
});
```

#### 인덱스 확인 필요
- `session.id` - 세션 조회용
- `user.phone` - 로그인용
- `userTrip.userId` - 여행 조회용
- `affiliateProfile.userId` - 파트너 조회용

---

### 2. API 응답 캐싱

**캐싱 가능한 API**:
- `/api/exchange-rate` - 1시간
- `/api/public/page-config` - 5분
- `/api/products` - 1분 (상품 목록)

**캐싱 불가능한 API**:
- `/api/auth/*` - 인증 관련
- `/api/chat/*` - 실시간 대화
- `/api/user/*` - 개인 정보

---

### 3. 이미지 최적화

**문제점**:
- 동적 이미지 로딩 없음
- WebP 형식 미지원
- Lazy loading 부족

**권장 해결책**:
- Next.js Image 컴포넌트 활용
- WebP 자동 변환
- CDN 활용 (Vercel Image Optimization)

---

## 🛡️ 에러 핸들링 개선 사항

### 1. 일관된 에러 응답 형식

**현재 문제**:
```typescript
// API마다 다른 에러 형식
{ ok: false, error: '...' }
{ success: false, error: '...' }
{ ok: false, message: '...' }
```

**권장 형식**:
```typescript
{
  ok: false,
  error: {
    code: 'ERROR_CODE',
    message: '사용자 친화적 메시지',
    details?: any
  }
}
```

### 2. 에러 로깅 강화

**현재**:
- 일부 API에서 에러 로깅 누락
- 에러 컨텍스트 부족

**개선**:
- 모든 API에서 구조화된 로깅
- 에러 추적을 위한 Request ID 추가
- Sentry 등 에러 모니터링 도구 도입

### 3. 사용자 친화적 에러 메시지

**현재**:
```typescript
error: 'Internal server error'
error: error.message // 기술적 메시지
```

**개선**:
```typescript
error: '일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요.'
// 기술적 에러는 로그에만 기록
```

---

## 📊 우선순위별 수정 권장 사항

### 🔴 P0 - 즉시 수정 (치명적)

1. **데이터베이스 연결 풀 설정**
   - 파일: `lib/prisma.ts`
   - 예상 시간: 30분
   - 영향: 100명 동시 접속 시 연결 고갈 방지

2. **로그인 API 트랜잭션 적용**
   - 파일: `app/api/auth/login/route.ts`
   - 예상 시간: 1시간
   - 영향: 동시 로그인 시 데이터 불일치 방지

3. **세션 조회 최적화**
   - 파일: `lib/session.ts`
   - 예상 시간: 2시간
   - 영향: DB 부하 90% 감소

4. **채팅 API 타임아웃 및 재시도**
   - 파일: `app/api/chat/route.ts`, `app/api/chat/stream/route.ts`
   - 예상 시간: 2시간
   - 영향: Gemini API 장애 시 서비스 안정성 향상

### 🟠 P1 - 우선 수정 (높음)

5. **Rate Limiter Redis 전환**
   - 예상 시간: 4시간
   - 영향: 분산 환경에서 효과적 Rate Limiting

6. **파일 업로드 큐 시스템**
   - 예상 시간: 6시간
   - 영향: Google Drive API Rate Limit 대응

7. **환율 API 캐싱 개선**
   - 예상 시간: 2시간
   - 영향: 외부 API 호출 99% 감소

8. **에러 핸들링 표준화**
   - 예상 시간: 8시간
   - 영향: 디버깅 및 사용자 경험 향상

### 🟡 P2 - 단계적 개선 (중간)

9. **데이터베이스 인덱스 최적화**
10. **API 응답 캐싱 전략**
11. **이미지 최적화**
12. **모니터링 도구 도입**

### 🟢 P3 - 모니터링 후 개선 (낮음)

13. **성능 메트릭 수집**
14. **사용자 행동 분석**
15. **A/B 테스트 인프라**

---

## 🧪 테스트 시나리오

### 동시성 테스트

```bash
# 100명 동시 로그인 테스트
for i in {1..100}; do
  curl -X POST http://localhost:3000/api/auth/login \
    -H "Content-Type: application/json" \
    -d '{"phone":"0101234'$i'","password":"3800","name":"테스트'$i'"}' &
done
wait

# 100명 동시 채팅 요청
for i in {1..100}; do
  curl -X POST http://localhost:3000/api/chat/stream \
    -H "Content-Type: application/json" \
    -d '{"text":"안녕하세요","mode":"chat"}' &
done
wait
```

### 부하 테스트 도구

- **k6**: 부하 테스트 스크립트 작성
- **Artillery**: API 부하 테스트
- **Apache Bench**: 간단한 부하 테스트

---

## 📈 모니터링 권장 사항

### 필수 메트릭

1. **데이터베이스**
   - 연결 풀 사용률
   - 쿼리 실행 시간
   - 트랜잭션 실패율

2. **API**
   - 응답 시간 (P50, P95, P99)
   - 에러율
   - Rate Limit 도달 횟수

3. **인프라**
   - 메모리 사용률
   - CPU 사용률
   - 네트워크 대역폭

### 도구 추천

- **Vercel Analytics**: 기본 메트릭
- **Sentry**: 에러 추적
- **Datadog/New Relic**: APM (선택)
- **Upstash Redis**: Rate Limiting 및 캐싱

---

## ✅ 체크리스트

### 즉시 확인 필요

- [ ] 데이터베이스 연결 풀 설정 확인
- [ ] Prisma 스키마 인덱스 확인
- [ ] 환경변수 `DATABASE_URL`에 connection_limit 확인
- [ ] Vercel 함수 타임아웃 설정 확인 (기본 10초)
- [ ] Gemini API Rate Limit 확인

### 단기 개선 (1주일 내)

- [ ] 로그인 API 트랜잭션 적용
- [ ] 세션 조회 최적화
- [ ] 채팅 API 타임아웃 추가
- [ ] 에러 핸들링 표준화

### 중기 개선 (1개월 내)

- [ ] Redis 기반 Rate Limiter
- [ ] 파일 업로드 큐 시스템
- [ ] 모니터링 도구 도입
- [ ] 성능 테스트 자동화

---

## 📝 결론

현재 크루즈몰 애플리케이션은 기본적인 기능은 잘 구현되어 있으나, **100명 동시 사용 시 여러 문제점이 발견**되었습니다.

**가장 시급한 문제**:
1. 데이터베이스 연결 풀 미설정
2. 세션 관리 비효율
3. 트랜잭션 부족

이 세 가지를 우선 수정하면 **안정성이 크게 향상**될 것입니다.

**예상 개선 효과**:
- 동시 접속자 처리 능력: 50명 → 200명
- API 응답 시간: 평균 20% 감소
- 에러율: 5% → 1% 이하
- 데이터베이스 부하: 50% 감소

---

**작성자**: AI Assistant  
**검토 필요**: 개발팀 리뷰 및 우선순위 조정


