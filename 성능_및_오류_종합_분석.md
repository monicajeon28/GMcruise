# 성능 및 오류 종합 분석 보고서

> 생성일: 2025-11-17
> 분석 범위: 전체 프로젝트

---

## 🔴 긴급 수정 필요 (Critical)

### 1. RAG 시스템의 심각한 성능 문제 ⚠️⚠️⚠️

**위치**: `lib/ai/ragSearch.ts` (94-98줄)

**문제점**:
- KnowledgeBase의 **각 문서마다** Google Embedding API를 호출
- 문서 100개 = API 호출 100번
- 문서 1000개 = API 호출 1000번
- **매 채팅마다** 실행됨

**영향**:
- API 비용 급증 (Google Embedding API는 유료)
- 응답 시간 지연 (100개 문서 = 수십 초)
- 서버 리소스 과다 사용

**현재 코드**:
```typescript
for (const item of knowledgeItems) {
  const itemEmbedding = await generateEmbedding(contentText); // ❌ 각 문서마다 API 호출
  const similarity = cosineSimilarity(normalizedQueryEmbedding, normalizedItemEmbedding);
}
```

**해결 방안**:
1. **임베딩을 DB에 저장** (권장)
   - KnowledgeBase 모델에 `embedding` 필드 추가 (JSON 타입)
   - 문서 생성/수정 시 한 번만 임베딩 생성
   - 검색 시에는 저장된 임베딩 사용

2. **캐싱 시스템 도입**
   - Redis 또는 메모리 캐시 사용
   - 동일한 문서는 재사용

3. **임베딩 생성 배치 처리**
   - 백그라운드 작업으로 처리
   - 실시간 검색은 키워드 기반으로 폴백

**예상 작업 시간**: 4-6시간

---

### 2. Scheduled Message Sender의 N+1 쿼리 문제 ⚠️⚠️

**위치**: `lib/scheduler/scheduledMessageSender.ts` (136-146줄)

**문제점**:
- 각 사용자마다 `findFirst`로 중복 확인
- 사용자 1000명 = 쿼리 1000번
- 매 5분마다 실행

**현재 코드**:
```typescript
for (const user of targetUsers) {
  const existingLog = await prisma.notificationLog.findFirst({ // ❌ N+1 쿼리
    where: { eventKey },
  });
}
```

**해결 방안**:
1. **배치 조회로 변경**
   ```typescript
   const eventKeys = targetUsers.map(u => 
     `SCHEDULED_MESSAGE_${message.id}_${stage.stageNumber}_${u.id}_${dateStr}`
   );
   const existingLogs = await prisma.notificationLog.findMany({
     where: { eventKey: { in: eventKeys } },
   });
   const sentEventKeys = new Set(existingLogs.map(log => log.eventKey));
   ```

2. **인덱스 추가**
   - `NotificationLog.eventKey`에 이미 unique 인덱스 있음 (OK)

**예상 작업 시간**: 1-2시간

---

### 3. Excel 업로드의 N+1 쿼리 문제 ⚠️⚠️

**위치**: `app/api/admin/customer-groups/excel-upload/route.ts` (128-144줄)

**문제점**:
- 각 행마다 `findFirst`와 `create` 호출
- 1000개 행 = 쿼리 2000번
- 타임아웃 위험

**현재 코드**:
```typescript
for (const row of batch) {
  let user = await prisma.user.findFirst({ // ❌ N+1 쿼리
    where: { phone: normalizedPhone },
  });
  if (!user) {
    user = await prisma.user.create({ // ❌ N+1 쿼리
      data: { ... },
    });
  }
}
```

**해결 방안**:
1. **배치 조회 및 생성**
   ```typescript
   const phones = batch.map(row => normalizePhone(row.phone));
   const existingUsers = await prisma.user.findMany({
     where: { phone: { in: phones } },
   });
   const existingPhones = new Set(existingUsers.map(u => u.phone));
   
   const newUsers = await prisma.user.createMany({
     data: phones.filter(p => !existingPhones.has(p)).map(phone => ({
       phone,
       password: '3800',
       // ...
     })),
   });
   ```

2. **트랜잭션 사용**
   - `prisma.$transaction`으로 묶어서 처리

**예상 작업 시간**: 2-3시간

---

## 🟡 중요 수정 필요 (Important)

### 4. Public Products API의 메모리 사용량

**위치**: `app/api/public/products/route.ts`

**문제점**:
- 모든 상품을 메모리에 로드한 후 JavaScript에서 필터링
- 상품이 많으면 메모리 부족 가능

**현재 코드**:
```typescript
let allProducts = await prisma.cruiseProduct.findMany({ // ❌ 모든 상품 로드
  // ...
});
// JavaScript에서 필터링
```

**해결 방안**:
- SQLite의 `LIKE` 연산자 사용 (대소문자 구분 없음)
- Prisma의 `contains` 사용 (SQLite는 지원하지만 대소문자 구분)
- 또는 검색 조건을 DB 쿼리로 옮기기

**예상 작업 시간**: 2-3시간

---

### 5. Admin Customers API의 복잡한 쿼리

**위치**: `app/api/admin/customers/route.ts`

**문제점**:
- 여러 번의 `findMany` 호출
- 복잡한 WHERE 조건

**현재 상태**: 
- 페이지네이션 있음 (OK)
- 인덱스 확인 필요

**해결 방안**:
- 인덱스 확인 및 추가
- 쿼리 최적화

**예상 작업 시간**: 1-2시간

---

### 6. Proactive Engine의 실행 빈도

**위치**: `lib/scheduler/proactiveEngine.ts`

**현재 상태**:
- 매 10분마다 실행
- 여러 `findMany` 쿼리 실행

**평가**:
- 실행 빈도는 적절함
- 쿼리는 인덱스가 있으면 괜찮음
- 하지만 사용자가 많아지면 느려질 수 있음

**개선 방안**:
- 쿼리 결과 캐싱
- 배치 처리 최적화

**예상 작업 시간**: 2-3시간

---

## 🟢 개선 권장 (Nice to Have)

### 7. 데이터베이스 인덱스 확인

**확인 필요 인덱스**:
- `User.phone` (이미 unique 인덱스 있음)
- `User.customerStatus`
- `Trip.status`
- `Itinerary.date`
- `NotificationLog.eventKey` (이미 unique 인덱스 있음)

**작업**: 인덱스 존재 여부 확인 및 추가

**예상 작업 시간**: 1-2시간

---

### 8. 스케줄러 실행 빈도 최적화

**현재 스케줄러**:
- Proactive Engine: 매 10분
- Scheduled Message Sender: 매 5분
- Trip Status Updater: 매일 자정
- Lifecycle Manager: 매일 새벽 2시
- RePurchase Trigger: 매일 새벽 3시
- Affiliate Link Cleanup: 매주 월요일 새벽 3시

**평가**: 적절함

---

### 9. AI API 호출 최적화

**현재 상태**:
- 채팅마다 Gemini API 호출
- RAG 검색마다 Embedding API 호출 (문제 있음 - 위 참조)

**개선 방안**:
- 응답 캐싱 (동일 질문 재사용)
- Rate limiting 추가

**예상 작업 시간**: 2-3시간

---

## 📊 통계 요약

### 데이터베이스 쿼리
- `findMany/findFirst/findUnique`: 721개
- `map/forEach/for` 루프: 545개
- 중첩 include: 26개 파일

### 스케줄러
- 총 6개 스케줄러 실행 중
- 가장 빈번한 실행: 매 5분 (Scheduled Message Sender)

### API 호출
- Gemini API: 채팅마다 호출
- Embedding API: RAG 검색마다 (문제 있음)

---

## 🎯 우선순위별 수정 계획

### Phase 1: 긴급 수정 (1-2일)
1. ✅ RAG 시스템 임베딩 DB 저장 (4-6시간)
2. ✅ Scheduled Message Sender N+1 쿼리 수정 (1-2시간)
3. ✅ Excel 업로드 N+1 쿼리 수정 (2-3시간)

### Phase 2: 중요 수정 (2-3일)
4. ✅ Public Products API 최적화 (2-3시간)
5. ✅ Admin Customers API 최적화 (1-2시간)
6. ✅ 데이터베이스 인덱스 확인 (1-2시간)

### Phase 3: 개선 (선택사항)
7. Proactive Engine 최적화 (2-3시간)
8. AI API 호출 캐싱 (2-3시간)

---

## 💰 비용 영향 분석

### 현재 예상 비용 (월간)
- Gemini API: 채팅 수 × $0.001 (예상)
- Embedding API: **문서 수 × 검색 수 × $0.0001** (⚠️ 매우 높음)
  - 예: 문서 100개, 검색 1000회 = $10/월
  - 문서 1000개, 검색 10000회 = $1000/월

### 수정 후 예상 비용
- Embedding API: 문서 생성/수정 시만 호출
  - 예: 문서 100개 생성 = $0.01 (한 번만)
  - 검색은 무료 (DB에서 조회)

**절감 효과**: 99% 이상 비용 절감 가능

---

## 🔧 수정 작업 체크리스트

- [ ] RAG 시스템 임베딩 DB 저장 구현
- [ ] Scheduled Message Sender 배치 조회로 변경
- [ ] Excel 업로드 배치 처리로 변경
- [ ] Public Products API 쿼리 최적화
- [ ] Admin Customers API 인덱스 확인
- [ ] 데이터베이스 인덱스 전체 점검
- [ ] 성능 테스트 및 벤치마크

---

## 📝 참고사항

1. **SQLite 제한사항**:
   - 대용량 데이터 처리 시 성능 저하 가능
   - 프로덕션에서는 PostgreSQL 권장

2. **메모리 사용량**:
   - 현재는 개발 환경이므로 문제 없음
   - 프로덕션 배포 시 모니터링 필요

3. **외부 API 의존성**:
   - Google Gemini API
   - Google Embedding API
   - YouTube API (선택사항)
   - 알리고 API (SMS/카카오톡, 미구현)

---

## 🚀 다음 단계

1. **즉시 수정**: RAG 시스템 임베딩 DB 저장
2. **단기 수정**: N+1 쿼리 문제 해결
3. **중기 개선**: 쿼리 최적화 및 인덱스 추가
4. **장기 개선**: 캐싱 시스템 도입







