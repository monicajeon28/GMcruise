# 판매원 대시보드 시뮬레이션 종합 리포트

## 📋 목차
1. [전체 기능 개요](#전체-기능-개요)
2. [어필리에이트 시스템 분석](#어필리에이트-시스템-분석)
3. [고객 관리 시스템 분석](#고객-관리-시스템-분석)
4. [구매 관리 시스템 분석](#구매-관리-시스템-분석)
5. [매출/정산 관리 분석](#매출정산-관리-분석)
6. [1만명 규모 효율성 분석](#1만명-규모-효율성-분석)
7. [발견된 문제점 및 개선사항](#발견된-문제점-및-개선사항)

---

## 전체 기능 개요

### 주요 기능 모듈
1. **대시보드**: 통계, 최근 리드/판매, 월별 판매 차트
2. **어필리에이트 링크 관리**: 판매 링크 생성/조회/공유
3. **고객 관리**: 리드 추가/수정/검색/필터링, 상담 기록
4. **구매 고객 관리**: 예약 조회, 여권 등록 링크 발송
5. **정산 관리**: 지급명세서 조회, 수당 조정 신청
6. **팀 관리**: 판매원 관리, 계약서 관리

---

## 어필리에이트 시스템 분석

### ✅ 정상 작동 기능
1. **링크 생성 및 관리**
   - 파트너몰 링크 자동 추적
   - 특정 상품 링크 생성 (관리자 생성)
   - 링크 상태 관리 (ACTIVE, EXPIRED, INACTIVE, REVOKED)

2. **링크 유효성 검사**
   - 백그라운드에서 링크 유효성 자동 검사
   - 유효한 링크만 표시 (검사 완료 후)

### ⚠️ 발견된 문제점

#### 1. 링크 통계 부재
**문제**: 링크별 클릭 수, 전환율, 판매 실적 추적이 명확하지 않음
- `AffiliateLink` 모델에 `_count.leads`, `_count.sales`는 있지만
- 실제 링크 클릭 추적 로직이 불명확
- 시간대별/기간별 통계 부재

**영향**: 링크 효과 측정 불가, 마케팅 전략 수립 어려움

#### 2. 랜딩페이지 링크 통합 관리 부재
**문제**: 랜딩페이지로 유입된 고객과 링크 추적이 분리됨
- `landingPageUserIds`로 고객 조회는 하지만
- 링크별 성과 추적이 안됨

**영향**: 어떤 랜딩페이지가 효과적인지 파악 불가

#### 3. 중복 링크 생성 가능성
**문제**: 동일 상품에 대해 여러 링크 생성 가능
- 중복 방지 로직 없음
- 링크 코드 중복 체크 미흡

**영향**: 통계 왜곡, 관리 혼란

---

## 고객 관리 시스템 분석

### ✅ 정상 작동 기능
1. **고객 추가/수정**
   - 이름, 전화번호로 고객 등록
   - 전화번호 정규화 (하이픈 제거 등)
   - 상태 관리 (NEW, IN_PROGRESS, CONVERTED, LOST 등)

2. **검색 및 필터링**
   - 이름, 전화번호로 검색
   - 상태별 필터링
   - 전화상담고객 필터 (source=mall)

3. **상담 기록**
   - 상담 내용 기록
   - 최근 상담 시간 추적
   - 판매원별 상담 기록 구분

### ⚠️ 발견된 문제점

#### 1. 페이지네이션 한계
**현재**: 최대 100개까지 (`MAX_PAGE_SIZE = 100`)
```typescript
const MAX_PAGE_SIZE = 100;
```

**문제**: 1만명 고객 관리 시 100페이지 넘게 페이지 전환 필요
- 기본 페이지 사이즈 20개
- 1만명 = 500페이지
- 페이지 전환 시마다 전체 쿼리 재실행

**영향**: 사용성 저하, 서버 부하

#### 2. 검색 성능 문제
**문제**: 전화번호 검색 시 여러 변형 생성 (`phoneSearchVariants`)
- 하이픈 포함/미포함 모두 조회
- OR 조건으로 여러 번 쿼리

**영향**: 고객 수가 많아질수록 검색 속도 저하

#### 3. 고객 소유권(Ownership) 복잡도
**문제**: 고객이 여러 판매원/대리점장 소유일 수 있음
- `resolveOwnership` 로직 복잡
- 판매원과 대리점장 모두 볼 수 있어 중복 표시 가능

**영향**: 고객 중복 관리, 판매 실적 집계 오류 가능

#### 4. 전화번호 중복 처리 미흡
**문제**: 동일 전화번호로 여러 고객 등록 가능
- User 테이블에는 중복 방지 있지만
- AffiliateLead에는 중복 가능
- Lead와 User 매핑 불명확

**영향**: 고객 데이터 중복, 통계 오류

#### 5. 랜딩페이지 고객 통합 관리 미흡
**문제**: 랜딩페이지로 등록된 고객이 Lead로 자동 변환 안됨
- 별도 조회 로직 필요
- Lead 생성 자동화 부재

**영향**: 고객 누락 가능, 추적 어려움

---

## 구매 관리 시스템 분석

### ✅ 정상 작동 기능
1. **예약 조회**
   - 예약 목록 조회 (최대 100개)
   - 고객 정보, 상품 정보, 여행자 정보 표시

2. **여권 등록 링크 발송**
   - 여권 등록 링크 SMS 발송
   - 여권 챗봇 링크 발송
   - 스마트폰 미리보기 기능

3. **APIS 상세정보 조회**
   - 여행자 정보 상세 조회
   - 여권 이미지 확인

### ⚠️ 발견된 문제점

#### 1. 예약-고객 매핑 복잡도
**문제**: 예약 조회 시 전화번호로 User 찾기
```typescript
// 전화번호 변형 생성 (하이픈 포함/미포함)
const phoneVariants = new Set<string>();
uniquePhoneDigits.forEach(digits => {
  phoneVariants.add(digits); // 숫자만
  if (digits.length === 11) {
    phoneVariants.add(`${digits.slice(0, 3)}-${digits.slice(3, 7)}-${digits.slice(7)}`);
  }
});
```

**문제점**:
- 전화번호 정규화가 일관되지 않음
- 여러 변형 생성으로 쿼리 비효율

**영향**: 예약 조회 누락 가능, 성능 저하

#### 2. 예약 목록 제한
**문제**: 최대 100개만 조회
```typescript
take: 100, // 최대 100개
```

**영향**: 대리점장이 관리하는 예약이 많으면 오래된 예약 조회 불가

#### 3. 예약 상태 동기화 부재
**문제**: 예약 상태(PNR status) 실시간 동기화 안됨
- 초기 생성 시점 상태만 저장
- 상태 변경 추적 없음

**영향**: 잘못된 상태 정보 표시

#### 4. 결제-예약 연결 불명확
**문제**: Payment와 Reservation 연결이 복잡
- Payment의 `affiliateMallUserId`, `affiliateCode`로 매핑
- 하지만 실제 예약과 연결은 User를 통해 간접적

**영향**: 결제 확인 어려움, 수수료 계산 오류 가능

---

## 매출/정산 관리 분석

### ✅ 정상 작동 기능
1. **판매 확인**
   - 판매 정보 등록
   - 판매 확인 대기 목록
   - 판매 승인 프로세스

2. **수수료 계산**
   - CommissionBreakdown 계산
   - 원천징수 자동 계산 (3.3%)
   - HQ, Branch, Sales 수수료 분배

3. **지급명세서**
   - 기간별 정산 명세서 조회
   - 엑셀 다운로드
   - 명세서 확인 기능

### ⚠️ 발견된 문제점 (매출 관련 - 매우 중요)

#### 1. 🔴 수수료 이중 집계 위험
**문제**: 판매원과 대리점장 모두 같은 판매에 대해 수수료 받을 수 있음
```typescript
// AffiliateSale 생성 시
if (agentId) {
  finalAgentId = agent.id;
  if (agent.agentRelations.length > 0) {
    finalManagerId = agent.agentRelations[0].managerId; // 둘 다 설정됨
  }
}
```

**위험 시나리오**:
- 판매원이 직접 판매 → 판매원 수수료 지급
- 대리점장도 같은 판매에 대해 수수료 지급 가능
- 수수료 계산 로직에서 둘 다 포함되면 이중 지급

**영향**: **매출 손실, 회계 오류**

#### 2. 🔴 수수료 계산 로직 검증 필요
**문제**: `calculateCommissionBreakdown` 로직 복잡
```typescript
const hqNet = Math.max(hqNetCandidate, 0);
// hqNet이 음수가 되면 0으로 처리
```

**위험**:
- branchCommission + salesCommission + overrideCommission의 합이 netRevenue를 초과하면
- hqNet이 0이 되고, 실제로는 수수료 총합이 수익을 초과
- 검증 로직 없음

**영향**: **수수료 과다 지급 가능**

#### 3. 🔴 Payment 조회 불안정
**문제**: Payment 조회 시 여러 방법 시도
```typescript
// 방법 1: Payment 직접 조회 (affiliateCode, affiliateMallUserId)
// 방법 2: AffiliateSale을 통해 조회
```

**문제점**:
- 두 방법 모두 실패하면 결제 내역 누락
- 조건이 맞지 않으면 빈 배열 반환
- 에러 처리 시 빈 배열 반환하여 문제 은폐

**영향**: **결제 누락, 정산 오류**

#### 4. 🔴 수수료 환불 처리 미흡
**문제**: 판매 취소/환불 시 수수료 차감 로직 불명확
- CommissionLedger에 차감 항목 추가 로직은 있지만
- 실제 환불 시 자동 차감 안됨

**영향**: **환불 후에도 수수료 지급되는 오류 가능**

#### 5. 원천징수율 하드코딩
**문제**: 원천징수율이 3.3%로 하드코딩
```typescript
export const DEFAULT_WITHHOLDING_RATE = 3.3;
```

**문제점**:
- 세법 변경 시 코드 수정 필요
- 판매원별 다른 원천징수율 적용 불가
- 과세/비과세 구분 없음

**영향**: **세무 처리 오류 가능**

#### 6. 정산 기간별 집계 성능
**문제**: 정산 명세서 생성 시 모든 Ledger 항목 조회
- 기간별로 전체 조회 후 집계
- 인덱싱 부족 시 느린 쿼리

**영향**: 정산 명세서 생성 지연

---

## 1만명 규모 효율성 분석

### 현재 구현 상태

#### ✅ 효율적인 부분
1. **페이지네이션 구현**
   - `parsePagination` 함수로 페이지네이션 처리
   - 기본 20개, 최대 100개 제한

2. **선택적 필드 조회**
   - `select` 사용으로 필요한 필드만 조회
   - 불필요한 관계 데이터 로드 방지

3. **동적 임포트**
   - 큰 컴포넌트는 동적 임포트
   - 초기 번들 크기 감소

#### ⚠️ 비효율적인 부분

#### 1. N+1 쿼리 문제
**문제**: 고객 목록 조회 시 여러 추가 쿼리
```typescript
// 1. AffiliateLead 조회
const leads = await prisma.affiliateLead.findMany(...);

// 2. User 정보 조회 (별도 쿼리)
const users = await prisma.user.findMany({
  where: { phone: { in: customerPhones } },
});

// 3. 판매 요약 조회 (별도 쿼리)
const saleGroups = await prisma.affiliateSale.groupBy(...);
```

**영향**: 
- 1만명 고객 조회 시 20개씩 페이징해도
- 각 페이지마다 3-5개 추가 쿼리
- 총 쿼리 수: 250-500개 (100페이지 기준)

**개선 필요**: JOIN 또는 include로 통합 쿼리

#### 2. 인덱스 부족 가능성
**문제**: 자주 사용하는 필터 필드 인덱스 확인 필요
- `customerPhone` 검색
- `managerId`, `agentId` 필터링
- `status` 필터링
- `createdAt`, `updatedAt` 정렬

**영향**: 전체 테이블 스캔 발생 가능

**확인 필요**: Prisma schema에서 인덱스 확인

#### 3. 메모리 사용량 증가
**문제**: 대량 데이터 조회 시 메모리 사용
```typescript
const monthlySales = await prisma.affiliateSale.groupBy({
  // 최근 6개월 데이터 모두 로드
});
```

**영향**: 
- 1만명 × 평균 판매 수 = 매우 큰 데이터셋
- 서버 메모리 부족 가능

#### 4. 페이지네이션 깊이 제한
**문제**: 페이지가 깊어질수록 OFFSET 비효율
- 500페이지 = OFFSET 10,000
- PostgreSQL은 OFFSET이 클수록 느려짐

**영향**: 뒷페이지 조회 시 매우 느림

**개선 필요**: 커서 기반 페이지네이션

#### 5. 실시간 통계 조회 부하
**문제**: 대시보드 통계를 매번 실시간 조회
```typescript
const [totalLinks, totalLeads, totalSales, teamMembers] = await Promise.all([...]);
```

**영향**: 
- 매 페이지 로드 시 통계 쿼리 실행
- 동시 사용자 증가 시 부하 급증

**개선 필요**: 캐싱 또는 배치 업데이트

---

## 발견된 문제점 및 개선사항

### 🔴 긴급 수정 필요 (매출 손실 방지)

#### 1. 수수료 이중 집계 방지
```typescript
// 수정 전: 판매원과 대리점장 모두 수수료 가능
// 수정 후: 판매원이 있으면 판매원만, 없으면 대리점장만

// lib/affiliate/commission.ts 수정 필요
if (options.agentProfileId) {
  // 판매원 수수료만 지급
  // 대리점장은 overrideCommission만
} else if (options.managerProfileId) {
  // 대리점장 직접 판매 수수료
}
```

#### 2. 수수료 총합 검증 추가
```typescript
// calculateCommissionBreakdown에 검증 추가
const totalCommission = branchCommission + salesCommission + overrideCommission;
if (totalCommission > netRevenue) {
  throw new Error('수수료 총합이 순수익을 초과합니다.');
}
```

#### 3. Payment 조회 로직 강화
```typescript
// 현재: 여러 방법 시도하지만 실패 시 조용히 실패
// 개선: 명확한 에러 메시지, 로깅 강화
if (payments.length === 0) {
  logger.warn('Payment 조회 실패', { partnerId, affiliateCode });
  // 관리자 알림 필요
}
```

### ⚠️ 중요 개선사항 (효율성)

#### 1. 데이터베이스 인덱스 추가
```prisma
// prisma/schema.prisma
model AffiliateLead {
  // ...
  @@index([managerId, status])
  @@index([agentId, status])
  @@index([customerPhone])
  @@index([createdAt])
}

model AffiliateSale {
  // ...
  @@index([managerId, saleDate])
  @@index([agentId, saleDate])
  @@index([status, saleDate])
}
```

#### 2. 커서 기반 페이지네이션 도입
```typescript
// 현재: OFFSET 기반
// 개선: 커서 기반
const leads = await prisma.affiliateLead.findMany({
  where: { ... },
  cursor: { id: lastId },
  take: limit,
});
```

#### 3. 통계 캐싱 도입
```typescript
// Redis 캐싱 또는 정기 배치 업데이트
const stats = await redis.get(`partner:${profileId}:stats`);
if (!stats) {
  // 계산 후 캐싱 (5분)
  await redis.setex(`partner:${profileId}:stats`, 300, JSON.stringify(stats));
}
```

#### 4. 검색 최적화
```typescript
// 전화번호 정규화를 DB에서 처리
// 또는 검색 전용 컬럼 추가
model AffiliateLead {
  customerPhone        String
  customerPhoneNormalized String @unique // 하이픈 제거된 전화번호
}
```

#### 5. 배치 처리 도입
```typescript
// 대량 데이터 처리 시 배치로 분할
async function processLeadsInBatches(leads: AffiliateLead[], batchSize = 100) {
  for (let i = 0; i < leads.length; i += batchSize) {
    const batch = leads.slice(i, i + batchSize);
    await processBatch(batch);
  }
}
```

### 💡 기능 개선 제안

#### 1. 고객 중복 감지 및 병합
- 동일 전화번호 고객 자동 감지
- 병합 기능 제공

#### 2. 링크 성과 추적 강화
- 클릭 수 추적
- 전환율 계산
- A/B 테스트 지원

#### 3. 예약 상태 실시간 동기화
- 주기적 상태 업데이트
- 변경 이력 추적

#### 4. 정산 알림 기능
- 정산 기간 알림
- 지급 완료 알림

---

## 결론

### 현재 상태
- ✅ 기본 기능은 잘 구현되어 있음
- ⚠️ 1만명 규모에서는 성능 저하 예상
- 🔴 수수료 계산 관련 매출 손실 위험 존재

### 우선순위
1. **긴급**: 수수료 이중 집계 방지, 검증 로직 추가
2. **높음**: 인덱스 추가, 페이지네이션 개선
3. **중간**: 통계 캐싱, 검색 최적화
4. **낮음**: 기능 개선 (링크 추적, 고객 병합 등)

### 예상 소요 시간
- 긴급 수정: 2-3일
- 효율성 개선: 1-2주
- 기능 개선: 1개월 이상

---

## 참고 파일

### 주요 파일 경로
- 대시보드: `app/partner/[partnerId]/dashboard/PartnerDashboard.tsx`
- 고객 관리: `app/api/partner/customers/route.ts`
- 구매 관리: `app/api/partner/reservations/route.ts`
- 수수료 계산: `lib/affiliate/commission.ts`
- 결제 조회: `app/api/partner/payments/route.ts`

### 데이터베이스 모델
- AffiliateLead: 고객 리드
- AffiliateSale: 판매 기록
- CommissionLedger: 수수료 원장
- Payment: 결제 내역
- Reservation: 예약 내역


