# 안전한 수정 가이드 - 기존 기능 보호

**작성 일시**: 2025년 1월 28일  
**목적**: 3일 체험 기능 개선 시 기존 기능이 망가지지 않도록 안전하게 수정하는 방법

---

## ✅ 안전하게 수정 가능한 항목들

### 1. 데이터베이스 연결 풀 설정 ⭐ **가장 안전**

**현재 상태**: 
- Prisma 설정에 주석만 있음
- DATABASE_URL에 파라미터 추가 방식

**안전한 수정 방법**:
```typescript
// lib/prisma.ts - 기존 코드는 그대로 유지
const prisma =
  globalThis.__prisma ??
  new PrismaClient({
    log: ['error', 'warn'],
    // 연결 풀 설정은 DATABASE_URL에 파라미터로 추가
    // 예: postgresql://user:pass@host:5432/db?connection_limit=20&pool_timeout=10
  });
```

**수정 위치**: `.env` 파일 또는 Vercel 환경 변수
```
DATABASE_URL=postgresql://...?connection_limit=20&pool_timeout=10
```

**영향도**: ✅ **영향 없음** - 단순히 연결 풀 크기만 제한하는 것이므로 기존 기능에 전혀 영향 없음

---

### 2. 파일 크기 제한 추가 ⭐ **매우 안전**

**현재 상태**: 
- `app/api/vision/route.ts`에 파일 크기 검증 없음

**안전한 수정 방법**:
```typescript
// app/api/vision/route.ts - 기존 로직은 그대로 유지
export async function POST(request: NextRequest) {
  try {
    // ... 기존 코드 ...
    
    const formData = await request.formData();
    const file = formData.get('image') as File | null;

    if (!file) {
      return NextResponse.json(
        { success: false, error: '이미지 파일이 없습니다.' },
        { status: 400 }
      );
    }

    // ✅ 새로 추가: 파일 크기 검증 (기존 로직 전에 추가)
    const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { success: false, error: '파일 크기는 10MB 이하여야 합니다.' },
        { status: 400 }
      );
    }

    // ... 나머지 기존 코드는 그대로 ...
  }
}
```

**영향도**: ✅ **거의 영향 없음** - 단지 큰 파일만 거부하는 것이므로 정상 사용자에게는 영향 없음

---

### 3. 외부 API 타임아웃 설정 ⭐ **안전**

**현재 상태**: 
- Gemini API 호출에 타임아웃 없음

**안전한 수정 방법**:
```typescript
// app/api/chat/stream/route.ts - 기존 로직은 그대로 유지
export async function POST(req: Request) {
  try {
    // ... 기존 코드 ...
    
    // ✅ 새로 추가: 타임아웃 설정
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30초
    
    try {
      // 기존 Gemini API 호출 코드는 그대로
      const result = await model.generateContentStream(/* ... */);
      
      clearTimeout(timeoutId);
      // ... 나머지 기존 코드 ...
    } catch (error) {
      clearTimeout(timeoutId);
      if (error.name === 'AbortError') {
        return new Response(JSON.stringify({ 
          error: '요청 시간이 초과되었습니다. 다시 시도해주세요.' 
        }), { 
          status: 408,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      throw error; // 기존 에러는 그대로 처리
    }
  }
}
```

**영향도**: ✅ **거의 영향 없음** - 단지 무한 대기만 방지하는 것이므로 정상 응답에는 영향 없음

---

### 4. access-check API 캐싱 ⭐ **안전**

**현재 상태**: 
- 매번 DB 조회

**안전한 수정 방법**:
```typescript
// app/api/user/access-check/route.ts - 기존 로직은 그대로 유지
export async function GET(req: NextRequest) {
  try {
    const sessionUser = await getSessionUser();
    if (!sessionUser) {
      // 기존 코드 그대로
      return NextResponse.json({ 
        ok: true, 
        allowed: true, 
        status: 'active',
        message: 'No session - public access'
      });
    }

    // ✅ 새로 추가: 클라이언트 캐싱 헤더 추가 (기존 로직은 그대로)
    const user = await prisma.user.findUnique({
      where: { id: sessionUser.id },
      select: { id: true, isLocked: true, testModeStartedAt: true },
    });

    // ... 기존 계산 로직은 그대로 ...

    // ✅ 응답에 캐시 헤더 추가 (기존 응답은 그대로)
    return NextResponse.json({
      ok: true,
      allowed: true,
      status: 'active',
    }, {
      headers: {
        'Cache-Control': 'private, max-age=300', // 5분 캐시
      }
    });
  }
}
```

**영향도**: ✅ **영향 없음** - 단지 캐싱만 추가하는 것이므로 기존 로직은 그대로

---

### 5. 만료된 사용자 기능 사용 제한 ⚠️ **주의 필요**

**현재 상태**: 
- 체크리스트, 가계부 등에서 만료 여부 확인 안 함

**안전한 수정 방법 (점진적 적용)**:

#### 방법 1: 헬퍼 함수 생성 (가장 안전)
```typescript
// lib/trial-check.ts - 새 파일 생성
import { getSessionUser } from '@/lib/auth';
import prisma from '@/lib/prisma';

export async function checkTrialExpired(): Promise<{ expired: boolean; message?: string }> {
  const user = await getSessionUser();
  if (!user) {
    return { expired: false };
  }

  const userData = await prisma.user.findUnique({
    where: { id: user.id },
    select: { testModeStartedAt: true },
  });

  if (!userData?.testModeStartedAt) {
    return { expired: false }; // 일반 사용자는 제한 없음
  }

  const testStartTime = new Date(userData.testModeStartedAt);
  const testExpireTime = new Date(testStartTime);
  testExpireTime.setHours(testExpireTime.getHours() + 72);
  const now = new Date();

  if (now > testExpireTime) {
    return { 
      expired: true, 
      message: '3일 체험이 종료되었습니다. 정식 서비스를 이용해주세요.' 
    };
  }

  return { expired: false };
}
```

#### 방법 2: 각 API에 점진적으로 추가 (기존 코드 보호)
```typescript
// app/api/checklist/route.ts - 기존 코드는 그대로 유지
export async function POST(req: NextRequest) {
  try {
    const user = await getSessionUser();
    if (!user) {
      return NextResponse.json(
        { error: '인증이 필요합니다' },
        { status: 401 }
      );
    }

    // ✅ 새로 추가: 3일 체험 만료 확인 (기존 로직 전에 추가)
    const trialCheck = await checkTrialExpired();
    if (trialCheck.expired) {
      return NextResponse.json(
        { error: trialCheck.message },
        { status: 403 }
      );
    }

    // ... 나머지 기존 코드는 그대로 ...
  }
}
```

**영향도**: ⚠️ **주의 필요** - 만료된 사용자만 영향받음 (의도된 동작)

**테스트 방법**:
1. 만료되지 않은 3일 체험 사용자로 테스트 → 정상 동작 확인
2. 일반 사용자(3800 비밀번호)로 테스트 → 정상 동작 확인
3. 만료된 3일 체험 사용자로 테스트 → 제한 확인

---

### 6. testModeStartedAt 동시 설정 방지 ⚠️ **주의 필요**

**현재 상태**: 
- Race Condition 가능성

**안전한 수정 방법**:
```typescript
// app/api/auth/login/route.ts - 기존 로직은 그대로 유지
// testModeStartedAt 설정 부분만 수정

// ❌ 기존 코드 (492-497번 줄)
// if (!testModeStartedAt) {
//   testModeStartedAt = now;
// }

// ✅ 안전한 수정
if (!testModeStartedAt) {
  // 트랜잭션으로 안전하게 설정
  await prisma.$transaction(async (tx) => {
    const currentUser = await tx.user.findUnique({
      where: { id: testUser.id },
      select: { testModeStartedAt: true },
    });
    
    // 다시 확인 (다른 요청이 이미 설정했을 수 있음)
    if (!currentUser?.testModeStartedAt) {
      await tx.user.update({
        where: { id: testUser.id },
        data: { testModeStartedAt: now },
      });
      testModeStartedAt = now;
    } else {
      testModeStartedAt = currentUser.testModeStartedAt;
    }
  });
}
```

**영향도**: ✅ **영향 없음** - 단지 동시성 문제만 해결하는 것이므로 기존 기능에는 영향 없음

---

## 🚫 수정하지 말아야 할 항목들

### 1. 로그인 로직 대폭 수정 ❌
- 현재 로그인 로직은 복잡하지만 정상 동작 중
- 대폭 수정하면 기존 사용자 로그인에 영향

### 2. 세션 관리 로직 변경 ❌
- 현재 세션 관리가 정상 동작 중
- 변경하면 로그인 상태 유지에 문제 발생 가능

### 3. 인증 로직 변경 ❌
- `getSessionUser()` 함수는 모든 API에서 사용 중
- 변경하면 전체 시스템에 영향

---

## 📋 안전한 수정 순서

### Phase 1: 완전히 안전한 수정 (즉시 적용 가능)
1. ✅ 데이터베이스 연결 풀 설정 (환경 변수만 수정)
2. ✅ 파일 크기 제한 추가 (검증만 추가)
3. ✅ 외부 API 타임아웃 설정 (에러 처리만 추가)

### Phase 2: 테스트 후 적용
4. ✅ access-check API 캐싱 (캐시 헤더만 추가)
5. ✅ testModeStartedAt 동시 설정 방지 (트랜잭션만 추가)

### Phase 3: 신중하게 적용
6. ⚠️ 만료된 사용자 기능 사용 제한 (헬퍼 함수로 점진적 적용)

---

## 🧪 테스트 체크리스트

각 수정 후 다음을 테스트:

### 기본 기능 테스트
- [ ] 일반 사용자(3800) 로그인
- [ ] 3일 체험 사용자(1101) 로그인
- [ ] AI 채팅 기능
- [ ] 이미지 업로드
- [ ] 체크리스트 추가/수정
- [ ] 가계부 추가/수정

### 3일 체험 기능 테스트
- [ ] 3일 체험 사용자 로그인
- [ ] 72시간 카운트다운 표시
- [ ] 만료 후 완료 안내 표시
- [ ] 만료된 사용자 기능 사용 제한 (Phase 3 적용 후)

### 동시성 테스트
- [ ] 여러 사용자 동시 로그인
- [ ] 여러 사용자 동시 기능 사용

---

## 💡 핵심 원칙

1. **기존 코드는 최대한 유지** - 새 코드만 추가
2. **점진적 적용** - 한 번에 하나씩 수정하고 테스트
3. **롤백 가능** - 수정 전에 커밋/백업
4. **에러 처리 강화** - 기존 에러 처리는 그대로 유지

---

## ✅ 결론

**대부분의 수정사항은 기존 기능에 영향을 주지 않습니다.**

- **안전한 수정**: 연결 풀, 파일 크기 제한, 타임아웃, 캐싱
- **주의 필요한 수정**: 만료된 사용자 제한 (하지만 의도된 동작)

**추천 접근 방법**:
1. Phase 1 수정사항부터 적용 (완전히 안전)
2. 각 수정 후 테스트
3. 문제 없으면 Phase 2로 진행
4. Phase 3는 신중하게 적용

**기존 기능이 망가질 가능성**: 매우 낮음 (5% 미만)
- 대부분의 수정은 기존 로직을 건드리지 않고 추가만 하는 방식
- 만료된 사용자 제한만 기존 동작을 변경하지만, 이는 의도된 동작


