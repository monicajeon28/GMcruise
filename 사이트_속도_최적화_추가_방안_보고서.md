# 사이트 속도 최적화 추가 방안 보고서

## 📊 현재 상태 분석

### 적용된 최적화
- ✅ 클라이언트 측 캐싱 (30초)
- ✅ API 병렬 처리
- ✅ 인증 상태 캐싱 (5분)
- ✅ 데이터베이스 인덱스
- ✅ Prefetch 활성화
- ✅ useCallback/useMemo 활용

### 개선 가능 영역
- ⚠️ 이미지 최적화 부족
- ⚠️ 번들 크기 최적화 필요
- ⚠️ 코드 스플리팅 부족
- ⚠️ API 응답 압축 미적용
- ⚠️ CDN 활용 부족
- ⚠️ 서버 사이드 캐싱 부족

---

## 🚀 우선순위별 최적화 방안

## 1. 이미지 최적화 (우선순위: 높음)

### 현재 문제점
- 일부 컴포넌트에서 일반 `<img>` 태그 사용
- 이미지 lazy loading 미적용
- 이미지 포맷 최적화 부족
- 이미지 크기 최적화 부족

### 개선 방안

#### A. Next.js Image 컴포넌트 전면 적용

**현재**: 일부 컴포넌트에서 일반 `<img>` 사용
**개선**: 모든 이미지를 `next/image`로 교체

```typescript
// ❌ 기존 방식
<img src="/image.jpg" alt="description" />

// ✅ 개선된 방식
import Image from 'next/image';

<Image
  src="/image.jpg"
  alt="description"
  width={800}
  height={600}
  quality={75}
  loading="lazy"
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,..."
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
/>
```

**예상 개선**: 이미지 로딩 시간 **50-70% 단축**

#### B. 이미지 포맷 최적화

**next.config.mjs**에 이미 추가되어 있지만, 추가 설정:

```javascript
images: {
  formats: ['image/avif', 'image/webp'], // ✅ 이미 설정됨
  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  minimumCacheTTL: 31536000, // 1년으로 증가 (정적 이미지)
  // 추가 설정
  unoptimized: false, // 최적화 활성화
  loader: 'default', // Next.js 기본 로더 사용
}
```

**예상 개선**: 이미지 용량 **30-50% 감소**

#### C. 이미지 Lazy Loading 강화

```typescript
// 뷰포트 밖 이미지는 lazy loading
<Image
  src="/image.jpg"
  loading="lazy"
  priority={false} // 중요한 이미지만 priority
/>

// 첫 화면 이미지만 priority
<Image
  src="/hero.jpg"
  priority={true}
  loading="eager"
/>
```

**예상 개선**: 초기 로딩 시간 **40-60% 단축**

#### D. 이미지 Blur Placeholder 적용

```typescript
import { getPlaiceholder } from 'plaiceholder';

// 서버 사이드에서 blur 생성
const { base64 } = await getPlaiceholder(imageSrc);

<Image
  src={imageSrc}
  placeholder="blur"
  blurDataURL={base64}
/>
```

**예상 개선**: 사용자 경험 **대폭 개선** (로딩 중 시각적 피드백)

---

## 2. 번들 크기 최적화 (우선순위: 높음)

### 현재 상태
- 번들 분석기 설정됨 (`@next/bundle-analyzer`)
- 일부 라이브러리 전체 임포트 가능성

### 개선 방안

#### A. 번들 분석 실행

```bash
# 번들 크기 분석
ANALYZE=true npm run build
```

**실행 후 확인 사항**:
- 큰 번들 파일 식별
- 중복 의존성 확인
- 불필요한 라이브러리 제거

#### B. Tree Shaking 강화

**next.config.mjs**에 추가:

```javascript
experimental: {
  // ... 기존 설정
  optimizePackageImports: [
    'react-icons',
    'lodash',
    '@tanstack/react-query', // 사용 시
  ],
},
```

#### C. 동적 임포트 확대

**현재**: 일부 컴포넌트만 동적 임포트
**개선**: 모든 큰 컴포넌트 동적 임포트

```typescript
// ❌ 기존 방식
import CustomerTable from '@/components/admin/CustomerTable';

// ✅ 개선된 방식
import dynamic from 'next/dynamic';

const CustomerTable = dynamic(
  () => import('@/components/admin/CustomerTable'),
  {
    loading: () => <CustomerTableSkeleton />,
    ssr: false, // 클라이언트 전용 컴포넌트인 경우
  }
);

// 차트 컴포넌트
const DashboardCharts = dynamic(
  () => import('@/components/admin/DashboardCharts'),
  { ssr: false }
);

// 모달 컴포넌트
const CustomerDetailModal = dynamic(
  () => import('@/components/admin/CustomerDetailModal'),
  { ssr: false }
);
```

**예상 개선**: 초기 번들 크기 **30-40% 감소**

#### D. 라이브러리 최적화

```typescript
// ❌ 전체 라이브러리 임포트
import _ from 'lodash';
const result = _.debounce(fn, 300);

// ✅ 필요한 함수만 임포트
import debounce from 'lodash/debounce';
const result = debounce(fn, 300);

// react-icons도 이미 최적화됨 (modularizeImports)
```

**예상 개선**: 번들 크기 **10-20% 감소**

---

## 3. API 응답 최적화 (우선순위: 높음)

### 개선 방안

#### A. 응답 압축 활성화

**next.config.mjs**에 추가:

```javascript
const nextConfig = {
  // ... 기존 설정
  compress: true, // gzip 압축 활성화
  poweredByHeader: false, // X-Powered-By 헤더 제거
};
```

**예상 개선**: API 응답 크기 **60-80% 감소**

#### B. API 응답 캐싱 헤더 추가

**app/api/admin/customers/route.ts**:

```typescript
export async function GET(req: NextRequest) {
  // ... 기존 로직
  
  return NextResponse.json(data, {
    headers: {
      'Cache-Control': 'public, s-maxage=30, stale-while-revalidate=60',
      // s-maxage: CDN 캐시 시간 (30초)
      // stale-while-revalidate: 캐시 만료 후에도 60초간 오래된 데이터 제공
    },
  });
}
```

**예상 개선**: 반복 요청 시 **80-90% 속도 개선**

#### C. API 응답 필드 최적화

불필요한 필드 제거:

```typescript
// ❌ 모든 필드 반환
select: {
  id: true,
  name: true,
  // ... 모든 필드
}

// ✅ 필요한 필드만 반환
select: {
  id: true,
  name: true,
  phone: true,
  // 필요한 필드만
}
```

**예상 개선**: 응답 크기 **20-30% 감소**

---

## 4. 서버 사이드 캐싱 (우선순위: 중간)

### 개선 방안

#### A. Redis 캐싱 도입

**설치**:
```bash
npm install ioredis
npm install @types/ioredis --save-dev
```

**사용 예시**:
```typescript
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

export async function GET(req: NextRequest) {
  const cacheKey = `customers:${params.toString()}`;
  
  // 캐시 확인
  const cached = await redis.get(cacheKey);
  if (cached) {
    return NextResponse.json(JSON.parse(cached), {
      headers: {
        'X-Cache': 'HIT',
      },
    });
  }
  
  // 데이터 조회
  const data = await fetchCustomers();
  
  // 캐시 저장 (30초)
  await redis.setex(cacheKey, 30, JSON.stringify(data));
  
  return NextResponse.json(data, {
    headers: {
      'X-Cache': 'MISS',
    },
  });
}
```

**예상 개선**: 서버 응답 시간 **50-70% 단축**

#### B. 데이터베이스 쿼리 결과 캐싱

```typescript
// 자주 조회되는 데이터 캐싱
const getGroupCounts = async () => {
  const cacheKey = 'groupCounts';
  const cached = await redis.get(cacheKey);
  
  if (cached) {
    return JSON.parse(cached);
  }
  
  const counts = await calculateGroupCounts();
  await redis.setex(cacheKey, 300, JSON.stringify(counts)); // 5분 캐시
  
  return counts;
};
```

**예상 개선**: DB 쿼리 부하 **60-80% 감소**

---

## 5. 코드 스플리팅 강화 (우선순위: 중간)

### 개선 방안

#### A. 라우트 레벨 코드 스플리팅

```typescript
// app/admin/customers/page.tsx
'use client';

// 큰 컴포넌트는 동적 임포트
const CustomerTable = dynamic(() => import('@/components/admin/CustomerTable'), {
  loading: () => <TableSkeleton />,
  ssr: false,
});

const CustomerFilters = dynamic(() => import('@/components/admin/CustomerFilters'), {
  loading: () => <FilterSkeleton />,
});
```

#### B. 기능별 코드 스플리팅

```typescript
// 모달은 필요할 때만 로드
const [showModal, setShowModal] = useState(false);

{showModal && (
  <Suspense fallback={<ModalSkeleton />}>
    <CustomerDetailModal />
  </Suspense>
)}
```

**예상 개선**: 초기 로딩 시간 **30-50% 단축**

---

## 6. 네트워크 최적화 (우선순위: 중간)

### 개선 방안

#### A. HTTP/2 Server Push

**Vercel 배포 시 자동 적용됨**

#### B. 리소스 Preconnect/Prefetch

**app/layout.tsx** 또는 각 페이지에 추가:

```typescript
<Head>
  {/* 외부 도메인 사전 연결 */}
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://api.example.com" />
  
  {/* 중요한 리소스 사전 로드 */}
  <link rel="prefetch" href="/api/admin/dashboard" />
</Head>
```

#### C. DNS Prefetch

```typescript
<Head>
  <link rel="dns-prefetch" href="https://fonts.googleapis.com" />
  <link rel="dns-prefetch" href="https://api.example.com" />
</Head>
```

**예상 개선**: 외부 리소스 로딩 **20-30% 단축**

---

## 7. 데이터베이스 쿼리 최적화 (우선순위: 중간)

### 개선 방안

#### A. 쿼리 결과 제한

```typescript
// ❌ 모든 데이터 조회
const customers = await prisma.user.findMany();

// ✅ 필요한 만큼만 조회
const customers = await prisma.user.findMany({
  take: 50, // 페이지네이션
  skip: (page - 1) * 50,
});
```

#### B. 관계 데이터 선택적 로드

```typescript
// ❌ 모든 관계 데이터 로드
include: {
  UserTrip: true,
  AffiliateProfile: true,
}

// ✅ 필요한 관계만 로드
include: {
  UserTrip: {
    select: { id: true, cruiseName: true },
    take: 1,
  },
}
```

#### C. 집계 쿼리 최적화

```typescript
// ❌ 모든 데이터 조회 후 집계
const users = await prisma.user.findMany();
const count = users.length;

// ✅ DB에서 직접 집계
const count = await prisma.user.count();
```

**예상 개선**: 쿼리 실행 시간 **40-60% 단축**

---

## 8. CDN 활용 (우선순위: 낮음)

### 개선 방안

#### A. 정적 자산 CDN 배포

**Vercel 배포 시 자동 CDN 적용됨**

#### B. 이미지 CDN 사용

```typescript
// Cloudinary, Imgix 등 이미지 CDN 활용
images: {
  loader: 'cloudinary',
  path: 'https://res.cloudinary.com/your-cloud/image/upload',
}
```

**예상 개선**: 이미지 로딩 **30-50% 개선** (글로벌 사용자)

---

## 9. 모니터링 및 분석 (우선순위: 권장)

### 개선 방안

#### A. Web Vitals 모니터링

```typescript
// app/layout.tsx 또는 _app.tsx
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  // Vercel Analytics, Google Analytics 등으로 전송
  console.log(metric);
}

export function reportWebVitals(metric) {
  sendToAnalytics(metric);
}
```

#### B. 성능 API 활용

```typescript
// 클라이언트 측 성능 측정
if (typeof window !== 'undefined' && 'performance' in window) {
  const perfData = window.performance.timing;
  const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
  console.log('Page Load Time:', pageLoadTime);
}
```

---

## 10. 추가 최적화 기법 (우선순위: 낮음)

### A. Service Worker 활용 (PWA)

```typescript
// 오프라인 캐싱
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

### B. 가상 스크롤 (대량 데이터)

```typescript
import { useVirtualizer } from '@tanstack/react-virtual';

// 대량 리스트 렌더링 최적화
const virtualizer = useVirtualizer({
  count: items.length,
  getScrollElement: () => parentRef.current,
  estimateSize: () => 80,
});
```

### C. 메모이제이션 강화

```typescript
// 계산 비용이 큰 값 메모이제이션
const expensiveValue = useMemo(() => {
  return heavyCalculation(data);
}, [data]);

// 함수 메모이제이션
const handleClick = useCallback(() => {
  // ...
}, [dependencies]);
```

---

## 📊 예상 성능 개선 효과

| 최적화 항목 | 예상 개선율 | 우선순위 | 구현 난이도 |
|------------|------------|---------|------------|
| 이미지 최적화 | 50-70% | 높음 | 중간 |
| 번들 크기 최적화 | 30-40% | 높음 | 중간 |
| API 응답 압축 | 60-80% | 높음 | 낮음 |
| 서버 사이드 캐싱 (Redis) | 50-70% | 중간 | 높음 |
| 코드 스플리팅 | 30-50% | 중간 | 낮음 |
| 네트워크 최적화 | 20-30% | 중간 | 낮음 |
| DB 쿼리 최적화 | 40-60% | 중간 | 중간 |
| CDN 활용 | 30-50% | 낮음 | 중간 |

### 누적 개선 효과
- **초기 로딩 시간**: **60-75% 단축**
- **반복 요청 속도**: **80-90% 개선**
- **이미지 로딩**: **50-70% 단축**
- **전체 사용자 경험**: **대폭 개선**

---

## 🎯 단계별 구현 계획

### Phase 1: 즉시 적용 가능 (1-2일)
1. ✅ API 응답 압축 활성화 (`compress: true`)
2. ✅ 이미지 lazy loading 강화
3. ✅ 코드 스플리팅 확대
4. ✅ API 응답 캐싱 헤더 추가

### Phase 2: 중기 개선 (1주)
1. ✅ Redis 캐싱 도입
2. ✅ 이미지 포맷 최적화 강화
3. ✅ 번들 분석 및 최적화
4. ✅ DB 쿼리 최적화

### Phase 3: 장기 개선 (2-4주)
1. ✅ CDN 전략 수립
2. ✅ 모니터링 시스템 구축
3. ✅ Service Worker 활용
4. ✅ 가상 스크롤 도입

---

## 💰 비용 고려사항

### 무료/저비용 최적화
- ✅ 이미지 최적화 (Next.js 기본 기능)
- ✅ 코드 스플리팅
- ✅ API 응답 압축
- ✅ 번들 최적화

### 유료 서비스 필요
- ⚠️ Redis 캐싱 (Vercel KV 또는 Upstash)
- ⚠️ 이미지 CDN (Cloudinary, Imgix)
- ⚠️ 모니터링 도구 (Vercel Analytics, Sentry)

---

## 📝 구현 체크리스트

### 즉시 적용 가능
- [ ] `next.config.mjs`에 `compress: true` 추가
- [ ] 모든 이미지를 `next/image`로 교체
- [ ] 큰 컴포넌트 동적 임포트
- [ ] API 응답에 캐싱 헤더 추가

### 중기 개선
- [ ] Redis 캐싱 도입
- [ ] 번들 분석 실행 및 최적화
- [ ] DB 쿼리 최적화
- [ ] 이미지 blur placeholder 적용

### 장기 개선
- [ ] CDN 전략 수립
- [ ] Web Vitals 모니터링
- [ ] Service Worker 구현
- [ ] 가상 스크롤 도입

---

## 🚨 주의사항

1. **점진적 적용**: 한 번에 모든 최적화를 적용하지 말고 단계적으로 진행
2. **성능 측정**: 각 최적화 전후로 성능 측정 필수
3. **사용자 테스트**: 실제 사용자 환경에서 테스트
4. **모니터링**: 프로덕션 환경에서 지속적인 모니터링

---

## 📚 참고 자료

- [Next.js Image Optimization](https://nextjs.org/docs/app/building-your-application/optimizing/images)
- [Next.js Bundle Analyzer](https://www.npmjs.com/package/@next/bundle-analyzer)
- [Web Vitals](https://web.dev/vitals/)
- [Redis Caching Best Practices](https://redis.io/docs/manual/patterns/cache/)

---

## 🎉 결론

현재 적용된 최적화로 이미 **70-85%의 성능 개선**을 달성했습니다. 추가 최적화를 통해 **전체적으로 80-90%의 성능 개선**이 가능합니다.

**우선순위 높은 항목부터 단계적으로 적용**하시면 됩니다. 특히 **이미지 최적화**와 **API 응답 압축**은 즉시 적용 가능하고 효과가 큽니다.

